<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Marcin Moskala</title>
    <description>The web page of Marcin Moskala</description>
    <link>http://www.marcinmoskala.com//</link>
    <atom:link href="http://www.marcinmoskala.com//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 17 Jun 2018 10:45:17 +0200</pubDate>
    <lastBuildDate>Sun, 17 Jun 2018 10:45:17 +0200</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Path of automatic Presenter lifecycle implementation</title>
        <description>&lt;p&gt;I am using MVP pattern in nearly all my Android projects. One of most discussive element of MVP is how we are implementing&lt;br /&gt;
its inner lifecycle. Purists would argue that we should specify concrete methods each time, &lt;br /&gt;
and explicitly call them in View:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;interface MainView {
}

class MainPresenter(val view: MainView) {
    fun onCreateActivity() {
        // Do sth.
    }
}

class MainActivity : Activity(), MainView {

    private val presenter = MainPresenter(this)
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        presenter.onCreateActivity()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Advantage of this approach is that we are explicitly defining what functions should be called. The problems are:&lt;br /&gt;
 * We need to define lifecycle every time we need it.&lt;br /&gt;
 * We need to call lifecycle methods explicitly in all Activities, Fragments etc.&lt;br /&gt;
Simpler approach is when we define lifecycle in &lt;code class=&quot;highlighter-rouge&quot;&gt;Presenter&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;interface Presenter {

    fun onCreate() {}

    fun onStart() {}

    fun onDestroy() {}

    fun onStop() {}

    fun onResume() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And its methods calls in &lt;code class=&quot;highlighter-rouge&quot;&gt;BaseActivityWithPresenter&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;abstract class BaseActivityWithPresenter : BaseActivity(), PresenterView {

    abstract val presenter: Presenter
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        presenter.onCreate()
    }

    override fun onStart() {
        super.onStart()
        presenter.onStart()
    }

    override fun onResume() {
        super.onResume()
        presenter.onResume()
    }

    override fun onStop() {
        super.onStop()
        presenter.onStop()
    }

    override fun onDestroy() {
        super.onDestroy()
        presenter.onDestroy()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Big advantage is that we can now easily extract common Presenter behaviors in separate classes. For example, here is &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;RxPresenter&lt;/code&gt; which is composing all &lt;code class=&quot;highlighter-rouge&quot;&gt;Disposable&lt;/code&gt; and disposing them in &lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;abstract class RxPresenter: Presenter {

    operator fun CompositeDisposable.plusAssign(disposable: Disposable) {
        add(disposable)
    }

    var subscriptions = CompositeDisposable()

    override fun onDestroy() {
        subscriptions.dispose()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using it, we can simply use RxJava in presenter while being sure that all subscriptions will be disposed when Activity is destroyed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;interface MainView {
    fun showUserData(user: User)
}

class MainPresenter(private val view: MainView) : RxPresenter() {

    private val userRepository by UserRepository.lazyGet()

    override fun onCreate() {
        subscriptions += userRepository.getUser()
                .applySchedulers()
                .subscribe(view::showUserData)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, if we have some common behaviors, like error handling, we can implement it in &lt;code class=&quot;highlighter-rouge&quot;&gt;BaseActivity&lt;/code&gt;, define in &lt;code class=&quot;highlighter-rouge&quot;&gt;BaseView&lt;/code&gt; and extend it by all views needs its methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;interface BaseView {
    fun showError(e: Throwable)
}

abstract class BaseActivityWithPresenter : BaseActivity(), PresenterView {
    
    fun showError(e: Throwable) {
        e.message?.let(this::toast)
        e.printStackTrace()
    }
    
    // ...
}

interface MainView: BaseView {
    fun showUserData(user: User)
}

class MainPresenter(private val view: MainView) : RxPresenter() {

    private val userRepository by UserRepository.lazyGet()

    override fun onCreate() {
        subscriptions += userRepository.getUser()
                .applySchedulers()
                .smartSubscribe(view::showUserData, view::showError)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is already big step forward - we have Presenter lifecycle defined, we can easily add common View methods and add &lt;br /&gt;
common Presenters functionalities. Last problem is that we can define this way only single presenter per Activity. &lt;br /&gt;
Presenter could be replaced with list of presenters, but it is making its usage harder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;abstract class BaseActivityWithPresenter : BaseActivity(), PresenterView {

    protected var presenters: List&amp;lt;Presenter&amp;gt; = emptyList()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        presenters.forEach { it.onCreate() }
    }

    override fun onStart() {
        super.onStart()
        presenters.forEach { it.onStart() }
    }

    override fun onResume() {
        super.onResume()
        presenters.forEach { it.onResume() }
    }

    override fun onStop() {
        super.onStop()
        presenters.forEach { it.onStop() }
    }

    override fun onDestroy() {
        super.onDestroy()
        presenters.forEach { it.onDestroy() }
    }
}

class MainActivity : Activity(), MainView, LoginView {

    private val mainPresenter = MainPresenter(this)
    private val loginPresenter = LoginPresenter(this)
    
    override fun onCreate(savedInstanceState: Bundle?) {
        presenters += mainPresenter
        presenters += loginPresenter
        super.onCreate(savedInstanceState)
        loginButton.setOnClickListener { loginPresenter.onLoginClicked() }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead, we might define property delegate to create presenter and add it to list of presenters. To make Activity &lt;br /&gt;
creation more efficient, we might want o make presenter creation lazy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;abstract class BaseActivityWithPresenter : BaseActivity(), PresenterView {

    fun &amp;lt;T: Presenter&amp;gt; presenter(init: ()-&amp;gt;T) = lazy(init).also { lazyPresenters += it }
    
    private var lazyPresenters: List&amp;lt;Lazy&amp;lt;Presenter&amp;gt;&amp;gt; = emptyList()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lazyPresenters.forEach { it.value.onCreate() }
    }

    override fun onStart() {
        super.onStart()
        lazyPresenters.forEach { it.value.onStart() }
    }

    override fun onResume() {
        super.onResume()
        lazyPresenters.forEach { it.value.onResume() }
    }

    override fun onStop() {
        super.onStop()
        lazyPresenters.forEach { it.value.onStop() }
    }

    override fun onDestroy() {
        super.onDestroy()
        lazyPresenters.forEach { it.value.onDestroy() }
    }
}

class MainActivity : Activity(), MainView, LoginView {

    private val mainPresenter by presenter { MainPresenter(this) }
    private val loginPresenter by presenter { LoginPresenter(this) }
        
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        loginButton.setOnClickListener { loginPresenter.onLoginClicked() }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last approach is finally connecting functionality and simplicity. This is also an approach that I am using currently in&lt;br /&gt;
my projects. I hope that this article inspired to make MVP simpler to use.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Sep 2017 00:00:00 +0200</pubDate>
        <link>http://www.marcinmoskala.com//android/kotlin/2017/09/30/presenter.html</link>
        <guid isPermaLink="true">http://www.marcinmoskala.com//android/kotlin/2017/09/30/presenter.html</guid>
        
        <category>Kotlin</category>
        
        <category>MVP</category>
        
        
        <category>Android</category>
        
        <category>Kotlin</category>
        
      </item>
    
      <item>
        <title>What do I hate in Kotlin</title>
        <description>&lt;p&gt;I love Kotlin. It is the best language I ever learned, and I really enjoy writing applications in it since over 2 years.&lt;br /&gt;
After all, like in even the best old marriage, I have a bunch of stuff that I hate and I know that most of them won’t change.&lt;br /&gt;
Most of them are not a big problems and they are it is hard to fall into them.&lt;br /&gt;
Still, they are there, and they are Kotlins fly in the ointment.&lt;/p&gt;

&lt;h1 id=&quot;the-legacy-of-java&quot;&gt;The legacy of Java&lt;/h1&gt;

&lt;p&gt;In Kotlin you cannot define this two functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;fun foo(strings: List&amp;lt;String&amp;gt;) {}
fun foo(ints: List&amp;lt;Int&amp;gt;) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is because both of them have the same JVM signature. This is not a Kotlin problem, but result of how they are compiled to Java bytecode.&lt;br /&gt;
It is just one way how Java legacy is influencing Kotlin execution. But there are bigger problems. For example, that&lt;br /&gt;
&lt;a href=&quot;https://kotlinlang.org/docs/reference/extensions.html#extensions-are-resolved-statically&quot;&gt;extensions are resolved statically&lt;/a&gt;.&lt;br /&gt;
This is a big problem, and I hope to write whole article just about it. For now - it is just problematic and unintuitive.&lt;br /&gt;
Thing is, that it was designed this way, because then extension functions are simply compiled to static functions with receiver on first&lt;br /&gt;
parameter. Now it needs to be implemented the same way in Kotlin\JavaScipt and Kotlin\Native. Just great.&lt;/p&gt;

&lt;h1 id=&quot;minus-operator-problems-and-other-unintuitive-operation-results&quot;&gt;Minus operator problems and other unintuitive operation results&lt;/h1&gt;

&lt;p&gt;Let’s look at this operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;println(listOf(2,2,2) - 2) // [2, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Result is intuitive- we are removing element from list so we get list without it. Now let’s look at this operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;println(listOf(2,2,2) - listOf(2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is the result? Empty list! Pretty unintuitive, and I &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-11453&quot;&gt;report it over a year ago&lt;/a&gt;.&lt;br /&gt;
But the answer was “As Designed”. It is true, while function description is following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;/*
// Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it doesn’t make it’s behavior better. This is one example of implementation that is unintuitive. Let’s look at some more unintuitive results:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&quot;1&quot;.toInt() // 1 - parsed to number
&#39;1&#39;.toInt() // 49 - its ASCII code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is correct, but wired in the same time. Note that predicates are true:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;1&quot;.toInt() != &#39;1&#39;.toInt()
&quot;1&quot;.toInt() != &quot;1&quot;[0].toInt()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;While any non-numeric character in &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; will cause &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberFormatException&lt;/code&gt;, there is also &lt;code class=&quot;highlighter-rouge&quot;&gt;toIntOrNull&lt;/code&gt; function for String that is returning null instead.&lt;br /&gt;
I think that it is good enough argument that this function should be named in different way in the first place. Maybe &lt;code class=&quot;highlighter-rouge&quot;&gt;parseInt&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Let’s go to another thing, but this one is more complex to understand: (thanks to &lt;a href=&quot;https://github.com/mg6maciej&quot;&gt;Maciej Górski&lt;/a&gt; for showing it to me)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Two last results are strange, aren’t they? The reason is that minus is not a part of the number, but unary extension function&lt;br /&gt;
to Int. This is why this two last lines are the same as:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unaryMinus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unaryMinus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is also as designed, and it wont change. Also, some will argue that it is how is how is should act. Let’s suppose that we made space behind Int:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now it looks rational. How it should be used? Number should be in bracket together with minus.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From rational point of view it is ok, but I think that everyone feels that &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt; should be a number, not &lt;code class=&quot;highlighter-rouge&quot;&gt;2.unaryMinus()&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;isolationism&quot;&gt;Isolationism&lt;/h1&gt;

&lt;p&gt;There are multiple Kotlin extensions to any object (like let, apply, run, also, to, takeIf, …), and I see lot’s of&lt;br /&gt;
creativity in their usage. In Kotlin, you can replace this definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;val list = if(student != null) {
    getListForStudent(student)
} else {
    getStandardList()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;val list = student?.let { getListForStudent(student) } ?: getStandardList()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, is is shorter and looks good. Also, when there are some other conditions added then we can still use it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;val list = student?.takeIf { it.passing }?.let { getListForStudent(student) } ?: getStandardList()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it is really better then simple, old if condition?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;val list = if(student != null &amp;amp;&amp;amp; student.passing) {
    getListForStudent(student)
} else {
    getStandardList()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I do not judge, but the fact is that implementation that is strongly using all Kotlin extensions are hard and unintuitive for people&lt;br /&gt;
who are not Kotlin developers. This kind of features are making Kotlin harder and harder for beginners. The big change comes with&lt;br /&gt;
Kotlin Coroutines. It is great feature. When I started learning it, then through whole day I was repeating “incretable” and “wow”.&lt;br /&gt;
It is awesome how Kotlin Coroutines are making multithreading so simple. I feel that this should be designed this way from the beginning of programming.&lt;br /&gt;
Still, it is complex to understand Kotlin Coroutines, and it is far away from how it is implemented in other technologies.&lt;br /&gt;
If community will start strongly using Coroutines, then it will be another barrier for programmers from other languages to jump in. This&lt;br /&gt;
leads to isolationism. And I feel that it is too early for that. Right now Kotlin is becoming more and more popular in Android and Web, and it just&lt;br /&gt;
started to be used in JavaScript and native. I think that this diversification is now much more important, and introduction&lt;br /&gt;
of Kotlin specific features should start later. Right now, there is still a lot of work to od in Kotlin\JavaScript and Kotlin\Native.&lt;/p&gt;

&lt;h1 id=&quot;tuples-vs-sam&quot;&gt;Tuples vs SAM&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.jetbrains.com/kotlin/migrating-tuples/&quot;&gt;Kotlin resigned from tuples&lt;/a&gt; and left just &lt;code class=&quot;highlighter-rouge&quot;&gt;Pair&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Triple&lt;/code&gt;.&lt;br /&gt;
The reason was that there should be data classes used instead.&lt;br /&gt;
What is the difference? Data class contains name, and all its properties are named too. Except that, it can be used like tuple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;data class Student(
        val name: String,
        val surname: String,
        val passing: Boolean,
        val grade: Double
)

val (name, surname, passing, grade) = getSomeStudent()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It the same time, Kotlin added support to Java SAM (Simple Abstract Method) by generation of lambda constructor and methods&lt;br /&gt;
that are containing lambda methods instead of Java SAM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;view.setOnClickListener { toast(&quot;Foo&quot;) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it is not working for SAM defined in Kotlin, because it is suggested to use functional types instead. What is the difference&lt;br /&gt;
between SAM and functional type? SAM contains name, and all its parameters are named too. Sure, from Kotlin 1.1 named functional type&lt;br /&gt;
 can be implemented by typealias:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;typealias OnClick = (view: View)-&amp;gt;Unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I still feel that there is lack of symmetry. If it is strongly suggested to use named data classes and tuples are prohibited, then&lt;br /&gt;
why it is suggested to use functional types instead of SAM and Kotlin SAM are not supported? Possible answer is that tuples are making more&lt;br /&gt;
problems then good in real-life projects. JetBrains have a lot of data about languages usage and they know how to analyze it.&lt;br /&gt;
They know a lot about how lambguage features are influencing development and I guess that they know what are they doing.&lt;br /&gt;
I just base on feeling that, it would be better if programmer could decide if he want to use tuple or data class.&lt;br /&gt;
And it is not isolationism, because tuples are implemented in most modern languages.&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;This are, in fact, just a small things. It is nothing comparing to what can be found in JavaScript, PHP or Ruby.&lt;br /&gt;
Kotlin was well designed from the beginning, and it is a solution to a lot of problems.&lt;br /&gt;
There are just some small stuff that didn’t go well enough.&lt;br /&gt;
Still it is, and it will be, my most favourite language for at least few more years.&lt;/p&gt;
</description>
        <pubDate>Wed, 31 May 2017 00:00:00 +0200</pubDate>
        <link>http://www.marcinmoskala.com//kotlin/2017/05/31/what-i-hate-in-kotlin.html</link>
        <guid isPermaLink="true">http://www.marcinmoskala.com//kotlin/2017/05/31/what-i-hate-in-kotlin.html</guid>
        
        <category>Kotlin</category>
        
        
        <category>Kotlin</category>
        
      </item>
    
      <item>
        <title>Still MVP or already MVVM?</title>
        <description>&lt;h4 id=&quot;still-mvp-or-already-mvvm&quot;&gt;Still MVP or already MVVM?&lt;/h4&gt;

&lt;p&gt;Everyone who applied clean MVP in the Android project knows, that it is not so simple. MVP is great because it allows us to unit-test presentation logic and separates it from view logic. Remember, that is nearly impossible to test Activity by unit-tests, while Presenter should be designed to allow that. This is why Presenter cannot contain any view elements (like Button, EditText etc.). The Presenter should apply changes on the View by invoking methods that are specified by an interface, which is in standard approach implemented by Activity or mocked by unit tests. Example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;interface MainView: PresenterBaseView {
    fun showToast(text: String)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class MainActivity : BaseActivity(), MainView {

    override fun showToast(text: String) {
        toast(text)
    }
    
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class MainPresenter(val view: MainView) {

    fun onStart() {
        view.showToast(&quot;I am working&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, clean guidelines are saying, that Activity should not depend on Data Model, so View methods should have just language basic types (Int, String) or mapper designed to pass bundle of data&lt;br /&gt;
(like in &lt;a href=&quot;https://github.com/android10/Android-CleanArchitecture/blob/master/presentation/src/main/java/com/fernandocejas/android10/sample/presentation/mapper/UserModelDataMapper.java&quot;&gt;Android-CleanArchitecture&lt;/a&gt;)&lt;br /&gt;
The result is that Activity is often full of 3-line methods, that are just setting something on layout or checking some properties:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;override fun getEmail(): String {
    return emailView.text.toString()
}

override fun setEmail(email: String) {
    emailView.text = email
}

override fun getPassword(): String {
    return passwordView.text.toString()
}

override fun setPassword(password: String) {
    passwordView.text = name
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is problematic, because:&lt;br /&gt;
* Someone needs to write it all&lt;br /&gt;
* Maintenance of such an amount of code is problematic. Any change needs a lot of other changes&lt;br /&gt;
* Boilerplate generates information noise&lt;br /&gt;
* It makes classes looks big and complex while they are doing nearly nothing&lt;/p&gt;

&lt;p&gt;Solution to this MVP problem was first implemented in C# by Microsoft, who made direct bindings from View &lt;br /&gt;
to Presenter (called then ViewModel). This solution is minimalistic and elegant, but sadly still poorly supported in Android.&lt;br /&gt;
Lot’s of passionates were really excited when Android added support for ViewBindings. It was some time ago and it is still weak. &lt;br /&gt;
I tried it myself and I agree with other opinions from the community that it is still pretty disappointing.&lt;/p&gt;

&lt;p&gt;I feel, that there is no need for magic. While Kotlin introduced Property Delegation, view bindings can be simply implemented&lt;br /&gt;
without any annotation processing or any magic proxy. And this idea stands behind &lt;a href=&quot;https://github.com/MarcinMoskala/KotlinAndroidViewBindings&quot;&gt;KotlinAndroidViewBindings&lt;/a&gt; library.&lt;/p&gt;

&lt;p&gt;Think about it this way: TextView is element of view, but from the presenter perspective, it is just field that contains some text. It is because it is the only important property for Presenter. Unless it also wants to change or read something else. Then it looks at View as text and some other property.&lt;/p&gt;

&lt;p&gt;For example, TextView in XML looks following:&lt;br /&gt;
```&lt;/p&gt;
&lt;textview android:id=&quot;@+id/registerButton&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:padding=&quot;10dp&quot; android:text=&quot;@string/action_go_to_register&quot; android:textcolor=&quot;@android:color/white&quot; /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
But from Presenter perspective is looks following:
```kotlin
interface MainView {
    var text: String
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Do we need to set some onClickListener? Then it looks as follow:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin
interface MainView {
    var text: String
    var onTextClicked: ()-&amp;gt;Unit
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It would be problematic to implement all this setters and getters, but with &lt;a href=&quot;https://github.com/MarcinMoskala/KotlinAndroidViewBindings&quot;&gt;KotlinAndroidViewBindings&lt;/a&gt; we can use Property Delegation to make bindings between properties and view element properties as simply as possible:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;var text by bindToText(R.id.emailView)
var onTextClicked by bindToRequestFocus(R.id.emailView)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time to some bigger example. It’s simple example from &lt;a href=&quot;https://github.com/MarcinMoskala/KotlinAndroidViewBindings&quot;&gt;KotlinAndroidViewBindings&lt;/a&gt;, and same similar example in wider context can be found on my &lt;a href=&quot;https://github.com/MarcinMoskala/SimpleKotlinMvpBoilerplate&quot;&gt;SimpleKotlinMvpBoilerplate&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For the need of presentation, I implemented login functionality. It is showing different errors and &lt;br /&gt;
requesting focus if field is incorrect according to validation. It is also showing loading when using repository. All logic is placed on Presenter, which is well unit-tested. View definition is following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;interface LoginView {
    var progressVisible: Boolean
    var email: String
    val emailRequestFocus: ()-&amp;gt;Unit
    var emailErrorId: Int?
    var password: String
    val passwordRequestFocus: ()-&amp;gt;Unit
    var passwordErrorId: Int?
    var loginButtonClickedCallback: ()-&amp;gt;Unit
    fun informAboutLoginSuccess(token: String)
    fun informAboutError(error: Throwable)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty big, but note that these are minimal capabilities. We just defined quite a complex functionality (we can split it into multiple presenters or views with presenters, but I decided to skip it to keep example more typical).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class LoginActivity : AppCompatActivity(), LoginView {

    override var progressVisible by bindToLoading(R.id.progressView, R.id.loginFormView)

    override var email by bindToTextView(R.id.emailView)
    override val emailRequestFocus by bindToRequestFocus(R.id.emailView)
    override var emailErrorId by bindToErrorId(R.id.emailView)

    override var password by bindToTextView(R.id.passwordView)
    override val passwordRequestFocus by bindToRequestFocus(R.id.passwordView)
    override var passwordErrorId by bindToErrorId(R.id.passwordView)

    override var loginButtonClickedCallback by bindToClick(R.id.loginButton)

    val presenter by lazy { LoginPresenter(this) }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)
        presenter.onCreate()
    }

    override fun onDestroy() {
        super.onDestroy()
        presenter.onDestroy()
    }

    override fun informAboutLoginSuccess(token: String) {
        toast(&quot;Login succeed. Token: $token&quot;)
    }

    override fun informAboutError(error: Throwable) {
        toast(&quot;Error: &quot; + error.message)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And Presenter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class LoginPresenter(val view: LoginView) {

    val loginUseCase by lazy { LoginUseCase() }
    val validateLoginFieldsUseCase by lazy { ValidateLoginFieldsUseCase() }
    var subscriptions: List&amp;lt;Subscription&amp;gt; = emptyList()

    fun onCreate() {
        view.loginButtonClickedCallback = { attemptLogin() }
    }

    fun onDestroy() {
        subscriptions.forEach { it.unsubscribe() }
    }

    fun attemptLogin() {
        val (email, password) = view.email to view.password
        subscriptions += validateLoginFieldsUseCase.validateLogin(email, password)
                .smartSubscribe(
                        onSuccess = { (emailErrorId, passwordErrorId) -&amp;gt;
                            view.passwordErrorId = passwordErrorId
                            view.emailErrorId = emailErrorId
                            when {
                                emailErrorId != null -&amp;gt; view.emailRequestFocus()
                                passwordErrorId != null -&amp;gt; view.passwordRequestFocus()
                                else -&amp;gt; sendLoginRequest(email, password)
                            }
                        },
                        onError = view::informAboutError
                )
    }

    private fun sendLoginRequest(email: String, password: String) {
        loginUseCase.sendLoginRequest(email, password)
                .applySchedulers()
                .smartSubscribe(
                        onStart = { view.progressVisible = true },
                        onSuccess = { (token) -&amp;gt; view.informAboutLoginSuccess(token) },
                        onError = view::informAboutError,
                        onFinish = { view.progressVisible = false }
                )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is all easy to unit-test with mocked View: (full tests &lt;a href=&quot;https://github.com/MarcinMoskala/SimpleKotlinMvpBoilerplate/blob/master/app/src/test/java/com/marcinmoskala/simplekotlinmvpboilerplate/LoginPresenterTest.kt&quot;&gt;here&lt;/a&gt;)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin
@Test
fun checkBothLoginFieldsEmpty() {
    val mockedView = MockedLoginView()
    val presenter = LoginPresenter(mockedView)
    presenter.onCreate()
    mockedView.loginButtonClickedCallback.invoke()
    checkValidity(mockedView,
            expectedEmailError = R.string.error_field_required,
            expectedPasswordError = R.string.error_field_required
    )
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;But what about initial question? Still MVP or already MVVM? Well, I am not sure. Too much philosophy. I prefer programming. And it is definitely useful.&lt;/p&gt;
</description>
        <pubDate>Fri, 05 May 2017 00:00:00 +0200</pubDate>
        <link>http://www.marcinmoskala.com//android/kotlin/2017/05/05/still-mvp-or-already-mvvm.html</link>
        <guid isPermaLink="true">http://www.marcinmoskala.com//android/kotlin/2017/05/05/still-mvp-or-already-mvvm.html</guid>
        
        <category>Kotlin</category>
        
        <category>Android</category>
        
        <category>KotlinAndroidViewBindings</category>
        
        
        <category>Android</category>
        
        <category>Kotlin</category>
        
      </item>
    
      <item>
        <title>FindMyPhone in 2 days?</title>
        <description>&lt;h4 id=&quot;findmyphone-in-2-days&quot;&gt;FindMyPhone in 2 days?&lt;/h4&gt;

&lt;p&gt;I was surprised how easy to use Firebase is. I wanted to test its abilities like login, a database with authentication, hosting and notifications.  So I invented a project that would use more them all. The idea was simple: User starts app and login using Google Authentication. If he lost his phone then he just needs to go to findmyphone.fun website, login into the same account and then click “FindMyPhone” so start alarm even if the phone is muted. It took me 2 days to write it.&lt;/p&gt;

&lt;div style=&quot;width: 50%; margin: 0 auto;&quot;&gt;
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/qWi_ElqcooI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;App was released and can be found on &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.marcinmoskala.findmyphone&quot;&gt;google play&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Code od Android application can be found here: &lt;br /&gt;
&lt;a href=&quot;https://github.com/MarcinMoskala/FindMyPhone&quot;&gt;https://github.com/MarcinMoskala/FindMyPhone&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It is written in Kotlin. The hardest part was Google Authentication part. It all can be found &lt;a href=&quot;https://github.com/MarcinMoskala/FindMyPhone/blob/master/app/src/main/java/com/marcinmoskala/findmyphone/presentation/main/GoogleLoginController.kt&quot;&gt;here&lt;/a&gt;. This authentication is pretty complex comparing to Facebook or VK login. I was doing it in the past without Firebase and I remember it as a big pain. But this time it took about 15 minutes to make it work thanks to Firebase support. Firebase project created in 3 clicks, JSON and Gradle plugin with all data added automatically.  Still pretty magical, which I don’t really like, but it is &lt;br /&gt;
working.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
    &lt;img src=&quot;http://www.marcinmoskala.com/static/img/blog/firebase_support.PNG&quot; alt=&quot;Firebase support&quot; style=&quot;height: 400px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Notifications also were simple with Firebase. I just needed to define service and that’s it. There is magic there I don’t like: If you define notification fields in sent notification and app is in the background, then it is shown as notification no matter what service is saying. Not only wired to me, but also pretty insecure. If somebody would steal the Token, then he could be able to send whatever notification he likes. Again: magic but it is working in no time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class RefreshTokenService : FirebaseInstanceIdService() {

    override fun onTokenRefresh() {
        val refreshedToken = FirebaseInstanceId.getInstance().token ?: return
        saveToken(refreshedToken)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The database from Android perspective is also really simple. Firebase database looks like a big map from String to String or another map. Sound scary for the bigger project, but perfect for small projects made for fun. The tricky part is how to secure it. The easiest way is to identify used by his UID and allow read and write only to branch with that UID:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;{
  &quot;rules&quot;: {
    &quot;$uid&quot;: {
      &quot;.write&quot;: &quot;$uid === auth.uid&quot;,
      &quot;.read&quot;: &quot;$uid === auth.uid&quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the code used to save token.:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;FirebaseDatabase
        .getInstance()
        .getReference(uid)
        .setValue(token) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is just setting branch to one equal to user UID (getReference(uid)) and then setting it’s value to token (setValue(token)).&lt;/p&gt;

&lt;p&gt;This are most tricky parts on the Android side. Time to make some hosting. Again: few clicks and it is alive. To make files locally all I needed is:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firebase init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;then I can make changes and deploy it on&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firebase deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or run locally by&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firebase serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Making Google Authentication is not so simple, but there are libraries that are making it easy. I used firebaseui. It took few hours to make it work, but when I did then the project was nearly ready. Notification sending is pretty easy because it is only one request to Google. Although I don’t like lack of support for that in all these firebase libraries. And weak documentation. Finally, I made it work in 2 days. Like in hackathons, but alone.&lt;/p&gt;

&lt;p&gt;As a conclusion, I feel that Firebase is designed to be perfect tools for Hackathons. It is simple and fast. Perfect for small projects. Really magical. I would be really careful before using it in an app designed for millions of users.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 May 2017 00:00:00 +0200</pubDate>
        <link>http://www.marcinmoskala.com//android/kotlin/2017/05/04/findmyphone.html</link>
        <guid isPermaLink="true">http://www.marcinmoskala.com//android/kotlin/2017/05/04/findmyphone.html</guid>
        
        <category>Firebase</category>
        
        <category>Kotlin</category>
        
        <category>Android</category>
        
        
        <category>Android</category>
        
        <category>Kotlin</category>
        
      </item>
    
  </channel>
</rss>
